<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Attt&#39;s Studio</title>
  
  
  <link href="http://attt.github.io/atom.xml" rel="self"/>
  
  <link href="http://attt.github.io/"/>
  <updated>2021-06-27T10:31:11.000Z</updated>
  <id>http://attt.github.io/</id>
  
  <author>
    <name>attt</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>位运算</title>
    <link href="http://attt.github.io/2021/06/23/Bits/"/>
    <id>http://attt.github.io/2021/06/23/Bits/</id>
    <published>2021-06-23T11:57:10.000Z</published>
    <updated>2021-06-27T10:31:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二进制中1的个数-Numbers-in-1-bits"><a href="#二进制中1的个数-Numbers-in-1-bits" class="headerlink" title="二进制中1的个数 (Numbers in 1 bits)"></a>二进制中1的个数 (Numbers in 1 bits)</h2><blockquote><p>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</p></blockquote><h3 id="BF"><a href="#BF" class="headerlink" title="BF"></a>BF</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>遍历每一位，判断是1，计数器+1，复杂度O(n)</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">      ans += ((n &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="无符号右移"><a href="#无符号右移" class="headerlink" title="无符号右移"></a>无符号右移</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>遍历的过程中，如果n已经是0了就跳出，对高位全是0的数有所优化，假设k是1的个数，复杂度是O(k)</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        ans += (n &amp; <span class="number">1</span>);</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="低位检查"><a href="#低位检查" class="headerlink" title="低位检查"></a>低位检查</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>如果要进一步降低复杂度，那就要只检查为1的位数，假设k是1的个数，复杂度为O(k)。</p><blockquote><p>假设n = $1001001_b$，则n-1 = $1001000_b$，n &amp; n - 1 = $1001000_b$。</p><p>假设n = $1001000_b$，则n-1 = $1000111_b$，n &amp; n - 1 = $1000000_b$。</p><p>每次n &amp; n - 1最低有效位（为1的位）会被消除。</p></blockquote><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        ans++;</span><br><span class="line">        n = n &amp; (n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="汉明距离-Hamming-distance"><a href="#汉明距离-Hamming-distance" class="headerlink" title="汉明距离 (Hamming distance)"></a>汉明距离 (Hamming distance)</h2><blockquote><p>两个整数之间的 <a href="https://baike.baidu.com/item/汉明距离">汉明距离</a> 指的是这两个数字对应二进制位不同的位置的数目。给你两个整数 <code>x</code> 和 <code>y</code>，计算并返回它们之间的汉明距离。</p></blockquote><h3 id="BF-1"><a href="#BF-1" class="headerlink" title="BF"></a>BF</h3><h4 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h4><p>遍历将x和y每一位对比，不同则计数器+1，复杂度O(n)。</p><h4 id="代码-3"><a href="#代码-3" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>((x &amp; <span class="number">1</span>) != (y &amp; <span class="number">1</span>)) ans++;</span><br><span class="line">      x &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">      y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="求异"><a href="#求异" class="headerlink" title="求异"></a>求异</h3><h4 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h4><p>将x和y异或后转为解决<a href="#二进制中1的个数-Numbers-in-1-bits">上一题</a>，复杂度最好为O(k)，k为汉明距离。</p><h4 id="代码-4"><a href="#代码-4" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingDistance</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> z = x ^ y;</span><br><span class="line">  <span class="keyword">while</span>(z != <span class="number">0</span>)&#123;</span><br><span class="line">    ans++;</span><br><span class="line">    z = z &amp; (z - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="汉明距离总和-Total-hamming-distance"><a href="#汉明距离总和-Total-hamming-distance" class="headerlink" title="汉明距离总和 (Total hamming distance)"></a>汉明距离总和 (Total hamming distance)</h2><blockquote><p>两个整数的 <a href="https://baike.baidu.com/item/汉明距离/475174?fr=aladdin">汉明距离</a> 指的是这两个数字的二进制数对应位不同的数量。给你一个整数数组 <code>nums</code>，请你计算并返回 <code>nums</code> 中任意两个数之间汉明距离的总和。</p></blockquote><h3 id="BF-2"><a href="#BF-2" class="headerlink" title="BF"></a>BF</h3><h4 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h4><p>遍历数组，计算汉明距离，然后相加，复杂度为O($n^2k$)，k是汉明距离，n是数组个数。</p><h4 id="代码-5"><a href="#代码-5" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; nums.length; j++)&#123;</span><br><span class="line">      <span class="comment">// hammingDistance(int,int) 计算两数汉明距离</span></span><br><span class="line">      ans += hammingDistance(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="乘法原理"><a href="#乘法原理" class="headerlink" title="乘法原理"></a>乘法原理</h3><h4 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h4><p>设i表示二进制位，$in_1$表示i位上为1的数的个数，$in_0$表示i位上为0的数的个数，计算nums中i位上的汉明距离则有$in = in_1 * in_0$。</p><h4 id="代码-6"><a href="#代码-6" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">totalHammingDistance</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> in1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)&#123;</span><br><span class="line">      <span class="keyword">if</span>((n &gt;&gt; i) == <span class="number">1</span>) in1++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans += in1 * (nums.length - in1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>设nums中的数都只有一位，nums的length为3，hammingDistance函数为hd，则有</p><script type="math/tex; mode=display">totalHammingDistance = hd(nums[0], nums[1]) + hd(nums[0], nums[2] + hd(nums[1], nums[2]))</script><ul><li>设$nums[0] = 1, nums[1] = 0, nums[2] = 0, n_1 = 1, n_0 = 2$</li></ul><script type="math/tex; mode=display">totalHammingDistance = 1 + 1 + 0 = 2 = n_1 * n_0</script><ul><li>设$nums[0] = 1, nums[1] = 1, nums[2] = 0,n_1 = 2,n_0 = 1$</li></ul><script type="math/tex; mode=display">totalHammingDistance = 0 + 1 + 1 = 2 = n_1 * n_0</script><ul><li>设$nums[0] = 1, nums[1] = 1, nums[2] = 1,n_1 = 3, n_0 = 0$</li></ul><script type="math/tex; mode=display">totalHammingDistance = 0 + 0 + 0 = 2 = n_1 * n_0</script><h2 id="猜字谜-Number-of-valid-word-for-each-puzzle"><a href="#猜字谜-Number-of-valid-word-for-each-puzzle" class="headerlink" title="猜字谜 (Number of valid word for each puzzle)"></a>猜字谜 (Number of valid word for each puzzle)</h2><blockquote><p>外国友人仿照中国字谜设计了一个英文版猜字谜小游戏，请你来猜猜看吧。</p><p>字谜的迷面 puzzle 按字符串形式给出，如果一个单词 word 符合下面两个条件，那么它就可以算作谜底：</p><p>​    单词 word 中包含谜面 puzzle 的第一个字母。<br>​    单词 word 中的每一个字母都可以在谜面 puzzle 中找到。</p><p>例如，如果字谜的谜面是 “abcdefg”，那么可以作为谜底的单词有 “faced”, “cabbage”, 和 “baggage”；而 “beefed”（不含字母 “a”）以及 “based”（其中的 “s” 没有出现在谜面中）都不能作为谜底。<br>返回一个答案数组 answer，数组中的每个元素 answer[i] 是在给出的单词列表 words 中可以作为字谜迷面 puzzles[i] 所对应的谜底的单词数目。</p></blockquote><h3 id="BF-3"><a href="#BF-3" class="headerlink" title="BF"></a>BF</h3><h4 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h4><p>遍历words和puzzles，对比每一个words和puzzles[i]中的字母，满足条件计1，复杂度O(nkpw)，n是words数，k是puzzles数，w是word字符数，p是puzzle字符数。</p><h4 id="代码-7"><a href="#代码-7" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">findNumOfValidWords</span><span class="params">(String[] words, String[] puzzles)</span> </span>&#123;</span><br><span class="line">  List&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span>(String puzzle : puzzles)&#123;</span><br><span class="line">    <span class="keyword">int</span> validNums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] puzzleCharArray = puzzle.toCharArray();</span><br><span class="line">    List&lt;Character&gt; puzzleCharList = Arrays.asList(puzzleCharArray);</span><br><span class="line">    <span class="keyword">char</span> firstChar = puzzleCharArray[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(String word : words)&#123;</span><br><span class="line">      <span class="keyword">char</span>[] wordCharArray = word.toCharArray();</span><br><span class="line">      List&lt;Character&gt; wordCharList = Arrays.asList(wordCharArray);</span><br><span class="line">      <span class="comment">// 不包含第一个字符</span></span><br><span class="line">      <span class="keyword">if</span>(!wordCharList.contains(firsChar)) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">boolean</span> valid = <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">char</span> wordChar : wordCharArray)&#123;</span><br><span class="line">        <span class="comment">// 含有不在puzzle中的字符</span></span><br><span class="line">        <span class="keyword">if</span>(!puzzleCharList.contains(wordChar))&#123;</span><br><span class="line">          vaid = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(valid) validNums++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.add(validNums);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><h4 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h4><p>将words和puzzles中每一个字符串转成26位二进制，复杂度O(nw + kp + nk)</p><h4 id="代码-8"><a href="#代码-8" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;Integer&gt; <span class="title">findNumOfValidWords</span><span class="params">(String[] words, String[] puzzles)</span> </span>&#123;</span><br><span class="line">  List&lt;Integer&gt; ans = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">int</span>[] wordMasks = masks(words);</span><br><span class="line">  <span class="keyword">int</span>[] puzzleMasks = masks(puzzles);</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; puzzleMasks.length; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> validNums = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> wordMask : wordMasks)&#123;</span><br><span class="line">      <span class="keyword">if</span>((wordMask &gt;&gt; (puzzles[i].toCharArray()[<span class="number">0</span>] - <span class="number">97</span>)) == <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">      <span class="keyword">if</span>((puzzleMasks[i] &amp; wordMask) == wordMask) validNums++;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.add(validNums);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] masks(String[] chars)&#123;</span><br><span class="line">  <span class="keyword">int</span>[] masks = <span class="keyword">new</span> <span class="keyword">int</span>[chars.length];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span>[] charArray = chars.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; charArray.length; j++)&#123;</span><br><span class="line">      mask |= (<span class="number">1</span> &lt;&lt; (j - <span class="number">97</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    masks[i] = mask;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> masks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="比特位计数-Counting-bits"><a href="#比特位计数-Counting-bits" class="headerlink" title="比特位计数 (Counting bits)"></a>比特位计数 (Counting bits)</h2><blockquote><p>给定一个非负整数 <strong>num</strong>。对于 <strong>0 ≤ i ≤ num</strong> 范围中的每个数字 <strong>i</strong> ，计算其二进制数中的 1 的数目并将它们作为数组返回。</p></blockquote><h3 id="BF-4"><a href="#BF-4" class="headerlink" title="BF"></a>BF</h3><h4 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h4><p>遍历0~num，计算每个数字二进制中的1，复杂度O(n*sizeof(integer))。</p><h4 id="代码-9"><a href="#代码-9" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">  <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">    ans[i] = hammingWeight(i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类快速幂-动态规划"><a href="#类快速幂-动态规划" class="headerlink" title="类快速幂/动态规划"></a>类快速幂/动态规划</h3><h4 id="思路-10"><a href="#思路-10" class="headerlink" title="思路"></a>思路</h4><p>$11$的1的个数可以由$1$推出，从小到大遍历的过程中可以由在小数的基础上算出大数的1数量，减少运算量，复杂度O(n)。</p><h4 id="代码-10"><a href="#代码-10" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] countBits(<span class="keyword">int</span> n) &#123;</span><br><span class="line">  <span class="keyword">int</span>[] ans = <span class="keyword">new</span> <span class="keyword">int</span>[n - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">    ans[i] = ans[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;二进制中1的个数-Numbers-in-1-bits&quot;&gt;&lt;a href=&quot;#二进制中1的个数-Numbers-in-1-bits&quot; class=&quot;headerlink&quot; title=&quot;二进制中1的个数 (Numbers in 1 bits)&quot;&gt;&lt;/a&gt;二进制中1的</summary>
      
    
    
    
    <category term="算法" scheme="http://attt.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="位运算" scheme="http://attt.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
    <category term="位运算" scheme="http://attt.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="算法" scheme="http://attt.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
    <category term="二进制" scheme="http://attt.github.io/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    <category term="leetcode" scheme="http://attt.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>快速幂、快速乘模板</title>
    <link href="http://attt.github.io/2021/06/21/BinaryExponentiationAlgAndBinaryMultiplicationAlg/"/>
    <id>http://attt.github.io/2021/06/21/BinaryExponentiationAlgAndBinaryMultiplicationAlg/</id>
    <published>2021-06-21T15:41:10.000Z</published>
    <updated>2021-06-23T16:50:21.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Binary Exponentiation &amp; Binary Multiplication </p></blockquote><h3 id="快速幂（Binary-Exponentiation、二进制幂、平方幂）"><a href="#快速幂（Binary-Exponentiation、二进制幂、平方幂）" class="headerlink" title="快速幂（Binary Exponentiation、二进制幂、平方幂）"></a>快速幂（Binary Exponentiation、二进制幂、平方幂）</h3><h4 id="算法理解"><a href="#算法理解" class="headerlink" title="算法理解"></a>算法理解</h4><ul><li><p>将幂分解： <script type="math/tex">x^a = x^{(a)_{bin}} = x^{a_1} * x^{a_2} * x^{a_3}</script>（其中 $^{(a)_{bin}}$ 是 $^a$ 的等价二进制，其中$^{a1}$、$^{a2}$、$^{a3}$是二进制各个位）让等价幂之间有倍数关系（因为是二进制），利用乘数的幂之间的关系，大幅简化运算（减少重复的计算）</p><ul><li>假设$^{a1}$、$^{a2}$、$^{a3}$按照高位到低位顺序，那么一定有 $x^{a1} = (x^{a2})^n = ((x^{a3})^n)^n, n&gt;=2$ ，那么 $x^{a1}$ 就可以通过倍乘 $x^{a2}$ 得出，简化了 $x^{a1}$ 需要的的计算。</li><li>假设 $x^n$  ，通常求幂方法是 <script type="math/tex">x^n = x*x*x*...*x</script>  (n个x), 复杂度是O(n)。快速幂的做法是 <script type="math/tex">x^n = x^n = x^{(n)_{bin}} = x^{(n1)_{bin}}*x^{(n2)_{bin}}* ...*x^{(nn)_{bin}}</script> , 复杂度是O(logn)。</li></ul></li></ul><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li><p>求 $x^{15}$ ，通常幂运算</p><script type="math/tex; mode=display">x^{15} = x * x * ... * x</script></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不考虑溢出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pow</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++)&#123;</span><br><span class="line">     x *= x;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>快速幂运算</p><script type="math/tex; mode=display">x^{15} = x^{(1111)_{bin}} = x^8 * x^4 * x^2 * x</script></li></ul> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不考虑溢出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binPow</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">15</span>;</span><br><span class="line">   <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">while</span>(i &gt; <span class="number">0</span>)&#123;</span><br><span class="line">     <span class="comment">// 检查此位</span></span><br><span class="line">     <span class="keyword">if</span>((i &amp; <span class="number">1</span>) == <span class="number">1</span>) result *= x;</span><br><span class="line">     <span class="comment">// x倍乘</span></span><br><span class="line">     x *= x;</span><br><span class="line">     <span class="comment">// 左移</span></span><br><span class="line">     i &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="快速乘法（Binary-Multiplication、二进制乘法、平方乘法）"><a href="#快速乘法（Binary-Multiplication、二进制乘法、平方乘法）" class="headerlink" title="快速乘法（Binary Multiplication、二进制乘法、平方乘法）"></a>快速乘法（Binary Multiplication、二进制乘法、平方乘法）</h3><h4 id="算法理解-1"><a href="#算法理解-1" class="headerlink" title="算法理解"></a>算法理解</h4><ul><li>和快速幂的思想差不多，<script type="math/tex">x*a = x*a_{bin} = x*(a1_{bin}+a2_{bin}+a3_{bin}) = x*a1_{bin}+x*a2_{bin}+x*a3_{bin}</script>，利用乘数之间的倍乘关系简化运算。</li></ul><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li>求<script type="math/tex">x*19</script>，即求<script type="math/tex">x*(10011)_{bin}=x *16 + x*2 + x</script></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不考虑溢出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binMul</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> t = <span class="number">19</span>;</span><br><span class="line">  <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(t &gt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>((t &amp; <span class="number">1</span>) == <span class="number">1</span>) result += x;</span><br><span class="line">    x *= x;</span><br><span class="line">    t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>快速幂和快速乘法模板适用于大数运算，用于降低复杂度和避免溢出。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;Binary Exponentiation &amp;amp; Binary Multiplication &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;快速幂（Binary-Exponentiation、二进制幂、平方幂）&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="算法" scheme="http://attt.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="位运算" scheme="http://attt.github.io/categories/%E7%AE%97%E6%B3%95/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    
    <category term="位运算" scheme="http://attt.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="快速幂" scheme="http://attt.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
    <category term="快速乘法" scheme="http://attt.github.io/tags/%E5%BF%AB%E9%80%9F%E4%B9%98%E6%B3%95/"/>
    
    <category term="算法" scheme="http://attt.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>HashMap杂谈</title>
    <link href="http://attt.github.io/2021/06/09/HashMap/"/>
    <id>http://attt.github.io/2021/06/09/HashMap/</id>
    <published>2021-06-09T02:50:18.000Z</published>
    <updated>2021-06-28T16:49:32.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ol><li><p>底层的原理</p></li><li><p>put get resize factor threshold</p></li><li><p>为什么使用数组+链表（树）</p></li><li><p>使用的hash算法是什么？简单和hash槽长度取模？</p><ol><li><p>hash值高低16位异或，然后和当前长度n减1进行与运算</p></li><li><p>补充说明：为什么是异或</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">本质是信息的平衡，此处将高低异或</span><br><span class="line">本就是考虑到如果只是和n-1进行与</span><br><span class="line">运算，那么原来hash值的高位的信息</span><br><span class="line">很容易丢失，异或运算需要两者的信</span><br><span class="line">息产生差异，而与运算、或运算极大</span><br><span class="line">可能是其中一者的信息。</span><br></pre></td></tr></table></figure></li></ol></li></ol><ol><li><p>hash冲突几种解决方案</p></li><li><p>用LinkedList代替数组可以吗，为什么不用，ArrayList呢？</p></li><li><p>jdk1.8中修改点，为什么</p><ol><li>引入了红黑树，在严重碰撞的情况下会有更好的查找效率</li><li>高低位异或，使得碰撞概率降低</li><li>改为尾插法<ol><li>其实头插法的初衷也挺扯的，“最后一次插入的节点有较大的几率会被先访问”这句话本身没有错，但是hash碰撞这件事本身就是应该通过规范的编码和选取hash算法来避免的，在这个前提下发生碰撞的概率应该很低，但是头插法引入的链表倒置问题却会有更大的概率产生</li></ol></li></ol></li><li><p>为什么会线程不安全，举例</p><ol><li><p>本质是什么呢？剥离hash map的其他细节，本质就是利用<code>临时链表</code>的<code>头插法</code>单向链表的倒置本身就是线程不安全的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">举个例子，假设现在有链表a-&gt;b，两个线程都要对该链表进行倒置，线程1到达b节点，将b</span><br><span class="line">节点的后指针指向a，然后线程1挂起，此时线程2到达a节点，由于此时临时链表已经有b节</span><br><span class="line">点了，移动a节点使得a节点的后指针指向b(头插),至此循环产生。</span><br></pre></td></tr></table></figure></li><li><p>补充说明：<code>临时链表</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如要倒置a-&gt;b，先产生一个空头节点（临时指针），然后遍历原链表：a头插入空节点为</span><br><span class="line">a-&gt;nil，b头插入临时链表为b-&gt;a-&gt;nil</span><br></pre></td></tr></table></figure></li><li><p>补充说明：<code>头插法</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在链表插入新元素的时候从头部插入，区别于“尾插法”</span><br></pre></td></tr></table></figure></li><li><p>补充说明：线程不安全除了扩容还体现在丢值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">比如线程1插入c元素，线程2插入d元素，两者槽位相同，槽中的链表为a-&gt;b，线程1修改c</span><br><span class="line">的后指针指向a，c-&gt;a-&gt;b然后挂起，线程2修改d的后指针指向a，d-&gt;a-&gt;b, 然后挂起，</span><br><span class="line">线程1将c作为头节点，执行结束，线程2将d作为头节点，结束。此时在槽中只能找到d、</span><br><span class="line">a、b，因为c节点已经被线程2的操作‘覆盖’了。</span><br></pre></td></tr></table></figure></li></ol></li><li><p>java8的尾插法就能保证线程安全了吗？</p><ol><li>不能，如上述补充说明最后一条描述的，还是会有丢值问题出现，如果要并发写入，应使用concurrentHashMap</li></ol></li><li><p>为什么扩容是2倍</p><ol><li>因为hash的时候是要用hash值去和n-1进行与运算的（n为原长度），如果是2的幂减1则所有位都为1，与运算分布更加均匀</li></ol></li><li><p>为什么在解决hash冲突时候，不直接用红黑树，而是先用链表，再用红黑树</p><ol><li>红黑树的插入和删除会有平衡操作，额外的开销</li></ol></li><li><p>当链表转为红黑树，什么时候退化为链表，为什么</p><ol><li>链表长度大于8的时候会转化为红黑树，小于6退回链表，隔7是考虑尽量避免频繁的插入删除造成的频繁转换</li></ol></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;知识点&quot;&gt;&lt;a href=&quot;#知识点&quot; class=&quot;headerlink&quot; title=&quot;知识点&quot;&gt;&lt;/a&gt;知识点&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;底层的原理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;put get resize factor threshold&lt;/p</summary>
      
    
    
    
    <category term="Java" scheme="http://attt.github.io/categories/Java/"/>
    
    <category term="数据结构" scheme="http://attt.github.io/categories/Java/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Java" scheme="http://attt.github.io/tags/Java/"/>
    
    <category term="Map" scheme="http://attt.github.io/tags/Map/"/>
    
    <category term="HashMap" scheme="http://attt.github.io/tags/HashMap/"/>
    
    <category term="数据结构" scheme="http://attt.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Fate/Grand Order 免逆向战斗数据修改</title>
    <link href="http://attt.github.io/2018/05/29/fgo-1/"/>
    <id>http://attt.github.io/2018/05/29/fgo-1/</id>
    <published>2018-05-29T15:30:11.000Z</published>
    <updated>2018-06-01T02:08:22.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>“仅作研究 :)”</p></blockquote><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>要修改数据一般有两个思路：</p><ol><li>修改本地函数</li><li>截获并修改响应数据</li></ol><h3 id="修改本地函数"><a href="#修改本地函数" class="headerlink" title="修改本地函数"></a>修改本地函数</h3><p>很显然如果要修改本地函数，首先要反编译找到调用点，然后修改函数逻辑，然后编译回去（可能还要重新签名）。</p><p>1.20.0版本对函数调用点进行了加密，当然可以在运行时debug提取关键代码（或者说关键的加密信息），但问题是这很需要耐心，👴🏻很没有耐心，除非google已经有答案了。</p><blockquote><p>过去版本利用reflector反编译<strong>Assembly-csharp.dll</strong>可以说近乎于获得了源码，但是淘宝那些黑心贩子获得源码最大的意义并不是修改本地数据，而是可以自定各种资源（增加菜单或者按钮之类的，傻瓜式的东西更好卖）。 </p><p><img src="/images/fgo-1/fgo-1-1.gif" alt="ui-hacker"> </p></blockquote><h3 id="截获并修改响应数据"><a href="#截获并修改响应数据" class="headerlink" title="截获并修改响应数据"></a>截获并修改响应数据</h3><h4 id="截获响应"><a href="#截获响应" class="headerlink" title="截获响应"></a>截获响应</h4><p>首先看能不能截获请求…key = battlesetup（规范化接口开发的好处体现出来了🐶），返回数据好像还是base64的</p><p><img src="/images/fgo-1/fgo-1-4.png" alt="fiddler"></p><p>解下base64…就直接是json了…（安全部门？</p><p><img src="/images/fgo-1/fgo-1-5.png" alt=""></p><p>格式化一下看看</p><p><img src="/images/fgo-1/fgo-1-6.png" alt="json-formatted"></p><p><img src="/images/fgo-1/fgo-1-7.png" alt="battle"></p><p>用第六感猜一下</p><p><img src="/images/fgo-1/fgo-1-8.png" alt="battleinfo"></p><h4 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h4><p>用fiddler的fiddler script(C#)功能，修改一下hp看看效果。</p><p><img src="/images/fgo-1/fgo-1-9.png" alt="fiddler script"></p><p>（给老婆加了10000hp）</p><p>准备阶段：</p><p><img src="/images/fgo-1/fgo-1-10.png" alt="进战斗之前"></p><p>战斗时：</p><p><img src="/images/fgo-1/fgo-1-11.png" alt="修改成功"></p><p>收工😄</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>能反root就反root</li><li>关键接口最好根据不同的安全级别加密（当然只用base64不算啊…</li><li>规范化接口开发可以提高维护效率，但是要和安全性进行取舍。</li><li>在重要指标上不要偷懒（平衡性，当然fgo其实是个单机游戏</li><li>可以适当降低某些东西的破解门槛，反用于保护关节逻辑，堵不如疏（比如礼装你让人很容易就篡改，就差不多有一半的人爽了，那战斗数据这些重点可能就少一半人懒得去破解，比如我）</li><li>小人防不住但君子还是要防的</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;“仅作研究 :)”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;思路分析&quot;&gt;&lt;a href=&quot;#思路分析&quot; class=&quot;headerlink&quot; title=&quot;思路分析&quot;&gt;&lt;/a&gt;思路分析&lt;/h2&gt;&lt;p&gt;要修改数据一般有两个思路：&lt;/p&gt;
</summary>
      
    
    
    
    <category term="hack" scheme="http://attt.github.io/categories/hack/"/>
    
    
    <category term="hack" scheme="http://attt.github.io/tags/hack/"/>
    
    <category term="gossip" scheme="http://attt.github.io/tags/gossip/"/>
    
    <category term="interception" scheme="http://attt.github.io/tags/interception/"/>
    
  </entry>
  
</feed>
